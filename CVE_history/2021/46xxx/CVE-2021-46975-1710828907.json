{
  "cveId": "CVE-2021-46975",
  "eventName": "CVE Translated",
  "cveChangeId": "6C709590-97BB-401E-A4A5-E850C13554A6",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "created": "2024-03-19T14:15:07.467",
  "details": [
    {
      "action": "Removed",
      "type": "Translation",
      "oldValue": "Title: kernel de Linux\nDescription: En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfilter: conntrack: Hacer que los sysctls globales sean de solo lectura en redes que no son init. Estos sysctls apuntan a variables globales: - NF_SYSCTL_CT_MAX (&amp;nf_conntrack_max) - NF_SYSCTL_CT_EXPECT_MAX (&amp;nf_ct_expect_max) - NF_SYSCTL_CT_BUCKETS (&amp;nf_conntrack_htable_size _user) Porque sus datos Los punteros no se actualizan para apuntar a estructuras por red, deben marcarse como de solo lectura en un ns que no sea init_net. De lo contrario, los cambios en cualquier espacio de nombres de red se reflejan (se filtran) en todos los demás espacios de nombres de red. Este problema existe desde la introducción de los espacios de nombres de red. La lógica actual los marca como de solo lectura si el espacio de nombres de red es propiedad de un usuario sin privilegios (que no sea init_user_ns). El commit d0febd81ae77 (\"netfilter: conntrack: volver a visitar sysctls en espacios de nombres sin privilegios\") \"expone todos los sysctls incluso si el espacio de nombres no tiene privilegios\". Dado que en cualquier caso necesitamos marcarlos como de sólo lectura, podemos prescindir por completo de la verificación de usuarios sin privilegios."
    }
  ]
}