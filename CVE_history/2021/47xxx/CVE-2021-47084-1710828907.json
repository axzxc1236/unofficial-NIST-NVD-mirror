{
  "cveId": "CVE-2021-47084",
  "eventName": "CVE Translated",
  "cveChangeId": "9A5C5082-69E6-4D0A-B3F9-C311EEC45B24",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "created": "2024-03-19T14:15:07.540",
  "details": [
    {
      "action": "Removed",
      "type": "Translation",
      "oldValue": "Title: kernel de Linux\nDescription: En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: hamradio: diferir ax25 kfree después de unregister_netdev Existe una posible condición de ejecución (use-after-free) como la siguiente (USE) | (GRATIS) ax25_sendmsg | ax25_queue_xmit | dev_queue_xmit | __dev_queue_xmit | __dev_xmit_skb | sch_direct_xmit | ... xmit_one | netdev_start_xmit | tty_ldisc_kill __netdev_start_xmit | mkiss_close ax_xmit | kfree ax_encaps | | Aunque hay dos primitivas de sincronización antes de kfree: 1. wait_for_completion(&amp;ax-&gt;dead). Esto puede evitar la ejecución con rutinas de mkiss_ioctl. Sin embargo, no puede detener la rutina que proviene de la capa superior, es decir, ax25_sendmsg. 2. netif_stop_queue(ax-&gt;dev). Parece que esta línea de código tiene como objetivo detener la cola de transmisión pero no logra detener la rutina que ya se está transmitiendo. Este parche reordena kfree después de unregister_netdev para evitar el posible UAF ya que unregister_netdev() está bien sincronizado y no regresará si hay una rutina en ejecución."
    }
  ]
}