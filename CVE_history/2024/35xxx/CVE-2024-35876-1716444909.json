{
  "cveId": "CVE-2024-35876",
  "eventName": "CVE Translated",
  "cveChangeId": "DBF03AC3-161A-4EE4-ADDE-AFAA76513287",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "created": "2024-05-23T14:15:09.830",
  "details": [
    {
      "action": "Removed",
      "type": "Translation",
      "oldValue": "Title: kernel de Linux\nDescription: En el kernel de Linux, se resolvió la siguiente vulnerabilidad: x86/mce: asegúrese de tomar mce_sysfs_mutex en set_bank() La modificación de los bits MCA_CTL de un banco MCA que controlan qué tipos de errores se informarán se realiza a través de /sys/devices/system/machinecheck / ??? machinecheck0? ??? bank0? ??? bank1? ??? bank10? ??? bank11 ... nodos sysfs escribiendo la nueva máscara de bits de eventos para habilitar. Cuando se acepta la escritura, el kernel elimina todos los temporizadores actuales y reinicia todos los banks. Hacer eso en paralelo puede llevar a inicializar un temporizador que ya está armado y en la rueda del temporizador, es decir, que ya está en uso: ODEBUG: init active (estado activo 0) objeto: ffff888063a28000 tipo de objeto: timer_list sugerencia: mce_timer_fn+0x0/0x240 arch /x86/kernel/cpu/mce/core.c:2642 ADVERTENCIA: CPU: 0 PID: 8120 en lib/debugobjects.c:514 debug_print_object+0x1a0/0x2a0 lib/debugobjects.c:514 Solucione eso tomando el mutex sysfs como el resto del código sysfs de MCA lo hace. Reportado por: Yue Sun  Reportado por: xingwei lee "
    }
  ]
}