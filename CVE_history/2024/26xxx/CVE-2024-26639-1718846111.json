{
  "cveId": "CVE-2024-26639",
  "eventName": "CVE Translated",
  "cveChangeId": "22DFA5A2-208E-4F90-902B-CA25BED102F3",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "created": "2024-06-20T09:15:11.183",
  "details": [
    {
      "action": "Removed",
      "type": "Translation",
      "oldValue": "Title: kernel de Linux\nDescription: En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm, kmsan: corrige la recursividad infinita debido a la sección crítica de RCU Alexander Potapenko escribe en [1]: \"Para cada acceso a memoria en el código instrumentado por KMSAN llamamos kmsan_get_metadata() para obtener los metadatos de la memoria a la que se accede. Para la memoria virtual, los punteros de metadatos se almacenan en la `página de estructura` correspondiente, por lo tanto, necesitamos llamar a virt_to_page() para obtenerlos. De acuerdo con el comentario en arch/x86/include/asm/page .h, virt_to_page(kaddr) devuelve un puntero válido si virt_addr_valid(kaddr) es verdadero, por lo que KMSAN también necesita llamar a virt_addr_valid(). Para evitar la recursividad, kmsan_get_metadata() no debe llamar al código instrumentado, por lo tanto ./arch/x86/ include/asm/kmsan.h bifurca partes de arch/x86/mm/physaddr.c para verificar si una dirección virtual es válida o no, pero la introducción de rcu_read_lock() a pfn_valid() agregó llamadas API de RCU instrumentadas a virt_to_page_or_null() , que es llamado por kmsan_get_metadata(), por lo que ahora hay una recursividad infinita. No creo que sea correcto detener esa recursividad haciendo kmsan_enter_runtime()/kmsan_exit_runtime() en kmsan_get_metadata(): eso evitaría que las funciones instrumentadas llamadas desde el tiempo de ejecución rastreen los valores ocultos, lo que podría introducir falsos positivos. problema al cambiar pfn_valid() a la variante _sched() de rcu_read_lock/unlock(), que no requiere llamar a RCU. Dado que la sección crítica en pfn_valid() es muy pequeña, esta es una compensación razonable (con RCU interrumpible ). Además, KMSAN debe tener cuidado de suprimir las llamadas al programador, lo que sería otra fuente de recursividad. Esto se puede hacer envolviendo la llamada a pfn_valid() en preempt_disable/enable_no_resched(). La desventaja es que esto sacrifica la interrupción de la programación. garantías; sin embargo, un kernel compilado con KMSAN ya ha renunciado a cualquier garantía de rendimiento debido a que está fuertemente instrumentado. Tenga en cuenta que el código KMSAN ya deshabilita el seguimiento a través de Makefile y, dado que mmzone.h está incluido, no es necesario usar la variante notrace, que generalmente se prefiere en todos los demás casos."
    }
  ]
}