{
  "cveId": "CVE-2024-39362",
  "eventName": "CVE Translated",
  "cveChangeId": "227F45E5-9227-4E4F-9E03-E00539142801",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "created": "2024-07-02T20:15:06.353",
  "details": [
    {
      "action": "Removed",
      "type": "Translation",
      "oldValue": "Title: kernel de Linux\nDescription: En el kernel de Linux, se resolvió la siguiente vulnerabilidad: i2c: acpi: desvincular adaptadores mux antes de eliminar Hay un problema con la eliminación de la tabla de superposición ACPI específicamente relacionado con los multiplexores I2C. Considere una superposición ACPI SSDT que define un mux I2C PCA9548 en un bus I2C existente. Cuando se carga esta tabla, vemos la creación de un dispositivo para el chip PCA9548 general y 8 dispositivos más, un i2c_adapter cada uno para los canales mux. Todos estos están vinculados a sus equivalentes ACPI mediante una eventual invocación de acpi_bind_one(). Cuando descargamos la superposición SSDT nos encontramos con el problema. Los dispositivos ACPI se eliminan normalmente a través de acpi_device_del_work_fn() y acpi_device_del_list. Sin embargo, se genera la siguiente advertencia y seguimiento de la pila ya que la eliminación no se realiza correctamente: ------------[ cortar aquí ]------------ kernfs: no se puede elimine 'physical_node', sin directorio ADVERTENCIA: CPU: 1 PID: 11 en fs/kernfs/dir.c:1674 kernfs_remove_by_name_ns+0xb9/0xc0 Módulos vinculados en: CPU: 1 PID: 11 Comm: kworker/u128:0 No contaminado 6.8 .0-rc6+ #1 Nombre de hardware: congatec AG conga-B7E3/conga-B7E3, BIOS 5.13 16/05/2023 Cola de trabajo: kacpi_hotplug acpi_device_del_work_fn RIP: 0010:kernfs_remove_by_name_ns+0xb9/0xc0 Código: e4 00 48 89 ef e8 07 71db ff 5b b8 fe ff ff ff 5d 41 5c 41 5d e9 a7 55 e4 00 0f 0b eb a6 48 c7 c7 f0 38 0d 9d e8 97 0a d5 ff &lt;0f&gt; 0b eb dc 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 RSP: 0018:ffff9f864008fb28 EFLAGS: 00010286 RAX: 0000000000000000 RBX: ffff8ef90a8d4940 RCX: 0000000000000000 RDX: 8f000e267d10 RSI: ffff8f000e25c780 RDI: ffff8f000e25c780 RBP: ffff8ef9186f9870 R08: 0000000000013ffb R09: 00000000ffffbfff R10: 00000000ffffbfff R11 : ffff8f000e0a0000 R12: ffff9f864008fb50 R13: ffff8ef90c93dd60 R14: ffff8ef9010d0958 R15: ffff8ef9186f98c8 FS: 0000000000000000(0000) GS:ffff8f000e240000(0000) 00000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007f48f5253a08 CR3: 00000003cb82e000 CR4: 00000000003506f0 Rastreo de llamadas: &lt; TAREA&gt; ? kernfs_remove_by_name_ns+0xb9/0xc0? __advertir+0x7c/0x130 ? kernfs_remove_by_name_ns+0xb9/0xc0? report_bug+0x171/0x1a0? handle_bug+0x3c/0x70? exc_invalid_op+0x17/0x70? asm_exc_invalid_op+0x1a/0x20? kernfs_remove_by_name_ns+0xb9/0xc0? kernfs_remove_by_name_ns+0xb9/0xc0 acpi_unbind_one+0x108/0x180 device_del+0x18b/0x490 ? srso_return_thunk+0x5/0x5f? srso_return_thunk+0x5/0x5f dispositivo_unregister+0xd/0x30 i2c_del_adapter.part.0+0x1bf/0x250 i2c_mux_del_adapters+0xa1/0xe0 i2c_device_remove+0x1e/0x80 dispositivo_release_driver_internal+0x19a/0x200 move_device+0xbf/0x100 dispositivo_del+0x157/0x490 ? __pfx_device_match_fwnode+0x10/0x10? srso_return_thunk+0x5/0x5f device_unregister+0xd/0x30 i2c_acpi_notify+0x10f/0x140 notifier_call_chain+0x58/0xd0 blocking_notifier_call_chain+0x3a/0x60 acpi_device_del_work_fn+0x85/0x1d0 34/0x2f0 hilo_trabajador+0x2f0/0x410 ? __pfx_worker_thread+0x10/0x10 kthread+0xe3/0x110 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x2f/0x50 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1b/0x30  ---[ end trace 0000000000000000 ]--- ... repetido 7 veces más, 1 por cada canal del mux ... El problema es que el enlace de los dispositivos ACPI a sus adaptadores I2C pares no se limpian correctamente. Profundizando en el problema, vemos que el orden de eliminación es tal que los dispositivos ACPI que coinciden con los adaptadores i2c del canal mux se eliminan primero durante la eliminación de la superposición SSDT. Para cada uno de los canales vemos una llamada a i2c_acpi_notify() con ACPI_RECONFIG_DEVICE_REMOVE pero, como estos dispositivos no son en realidad i2c_clients, no se hace nada por ellos. Más adelante, después de haber tratado cada uno de los canales mux, procedemos a eliminar el i2c_client que representa el dispositivo PCA9548.  ---truncados---"
    }
  ]
}