{
  "cveId": "CVE-2024-46839",
  "eventName": "CVE Translated",
  "cveChangeId": "1F9F7E3A-911F-4936-8339-95764CA696C4",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "created": "2024-10-01T14:15:06.340",
  "details": [
    {
      "action": "Removed",
      "type": "Translation",
      "oldValue": "Title: kernel de Linux\nDescription: En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: workqueue: Mejorar la escalabilidad del watchdog de workqueue touch En un sistema powerpc de ~2000 CPU, se han observado bloqueos duros en el código de workqueue cuando se ejecuta stop_machine (en este caso debido a la conexión en caliente de la CPU). Esto se debe a que muchas CPU giran en multi_cpu_stop, llamando a touch_nmi_watchdog() que termina llamando a wq_watchdog_touch(). wq_watchdog_touch() escribe en la variable global wq_watchdog_touched, y esta puede encontrarse en la misma línea de caché que otros datos importantes de workqueue, lo que ralentiza las operaciones hasta el punto de bloquearse. En el caso del siguiente seguimiento abreviado, worker_pool_idr estaba en la línea directa, lo que hacía que los bloqueos siempre aparecieran en idr_find. watchdog: CPU 1125 autodetectó BLOQUEO duro @ idr_find Seguimiento de llamadas: get_work_pool __queue_work call_timer_fn run_timer_softirq __do_softirq do_softirq_own_stack irq_exit timer_interrupt decrementer_common_virt * interrupción: 900 (temporizador) en multi_cpu_stop multi_cpu_stop cpu_stopper_thread smpboot_thread_fn kthread Solucione esto haciendo que wq_watchdog_touch() solo escriba en la línea si la última vez que se registró un toque excede 1/4 del umbral del watchdog."
    }
  ]
}